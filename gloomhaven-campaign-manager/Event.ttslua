local Constant = require("sebaestschjin-tts.Constant")
local DeckUtil = require("sebaestschjin-tts.DeckUtil")
local ObjectUtil = require("sebaestschjin-tts.ObjectUtil")
local TableUtil = require("sebaestschjin-tts.TableUtil")
local Utils = require("sebaestschjin-tts.Utils")

local Component = require("gloomhaven-campaign-manager.Component")

local Event = {}

---@shape gh_EventDeckInfo
---@field initialDeckGuid GUID
---@field deckGuid GUID
---@field snapPoint number
---@field name string
---@field oldMat nil | GUID

---@type table<string, gh_EventDeckInfo>
Event.DECKS = {
    ["city"] = {
        initialDeckGuid = Component.guids.CITY_EVENTS_DECK_INITIAL,
        deckGuid = Component.guids.CITY_EVENTS_DECK,
        snapPoint = Component.snaps.CITY_EVENTS_DECK,
        name = Component.names.CITY_EVENTS,
    },
    ["road"] = {
        initialDeckGuid = Component.guids.ROAD_EVENTS_DECK_INITIAL,
        deckGuid = Component.guids.ROAD_EVENTS_DECK,
        snapPoint = Component.snaps.ROAD_EVENTS_DECK,
        name = Component.names.ROAD_EVENTS,
        oldMat = Component.guids.OLD_EVENT_MAT,
    },
}

---@param events gh_Save_EventDeck[]
function Event.loadAll(events)
    for _, eventDeck in ipairs(events) do
        Event.load(eventDeck)
    end
end

---@param events gh_Save_EventDeck
function Event.load(events)
    local eventsInfo = Event.DECKS[events.deck]
    local deck = DeckUtil.wrap(--[[---@type tts__Deck]] getObjectFromGUID(eventsInfo.deckGuid))
    deck.putObject(--[[---@not nil]] getObjectFromGUID(eventsInfo.initialDeckGuid))

    local bottomCards = Event.findBottomDeck(events, deck)
    local addedCards = Event.findAddedCards(events, deck, bottomCards)

    TableUtil.shuffle(addedCards)
    local eventCards = TableUtil.merge(bottomCards, addedCards)

    Event.dealEvents(deck, eventCards, eventsInfo)
end

---@param events gh_Save_EventDeck
---@param deck common_DeckZone
---@return GUID[]
function Event.findBottomDeck(events, deck)
    local eventsToAdd = {}
    for _, event in TableUtil.pairs(events.bottomUp) do
        local eventName = string.format("%02d", event)
        local eventCard = --[[---@not nil]] Utils.findObjectIn(deck, { name = eventName })
        table.insert(eventsToAdd, eventCard.getGUID())
    end

    return eventsToAdd
end

---@param events gh_Save_EventDeck
---@param deck common_DeckZone
---@param alreadyAdded GUID[]
---@return GUID[]
function Event.findAddedCards(events, deck, alreadyAdded)
    local eventsToAdd = {}
    for _, eventCard in ipairs(deck.getObjects()) do
        local eventNumber = --[[---@not nil]] tonumber(eventCard.name)
        if not TableUtil.contains(alreadyAdded, eventCard.guid)
                and Event.isAdded(events, eventNumber)
                and not Event.isRemoved(events, eventNumber)
        then
            table.insert(eventsToAdd, eventCard.guid)
        end
    end

    return eventsToAdd
end

---@param events gh_Save_EventDeck
---@param eventNumber number
---@return boolean
function Event.isRemoved(events, eventNumber)
    return events.remove and TableUtil.contains(events.remove, eventNumber)
end

---@param events gh_Save_EventDeck
---@param eventNumber number
---@return boolean
function Event.isAdded(events, eventNumber)
    return eventNumber <= 30
            or (events.add and TableUtil.contains(events.add, eventNumber))
end

---@param deck common_DeckZone
---@param eventCards GUID[]
function Event.dealEvents(deck, eventCards, info)
    local eventDeck = Event.getTargetDeck(info)
    for _, event in pairs(eventCards) do
        deck.takeObject({
            guid = event,
            position = Component.getSafePosition(),
            rotation = Constant.Rotation.NORTH,
            smooth = false,
            callback_function = function(card) eventDeck.putObject(card) end
        })
    end
end

---@return gh_Save_EventDeck[]
function Event.save()
    local events = --[[---@type gh_Save_EventDeck[] ]]{}

    for name, info in pairs(Event.DECKS) do
        local eventDeck = Event.saveEventsFromDeck(info)
        if eventDeck then
            (--[[---@not nil]] eventDeck).deck = name
            table.insert(events, --[[---@not nil]] eventDeck)
        end
    end

    return TableUtil.emptyToNil(events)
end

---@param info gh_EventDeckInfo
---@return nil | gh_Save_EventDeck
function Event.saveEventsFromDeck(info)
    local eventDeck = Event.getTargetDeck(info)
    local eventsFromDeck = --[[---@type gh_Save_EventDeck]] { bottomUp = {}, remove = {} }

    for _, card in pairs(ObjectUtil.getContainedObjects(eventDeck)) do
        local eventNumber = Event.getNumber(card)
        table.insert(eventsFromDeck.bottomUp, eventNumber)
    end

    for i = 1, 30 do
        if not TableUtil.contains(eventsFromDeck.bottomUp, i) then
            table.insert(eventsFromDeck.remove, i)
        end
    end
    if TableUtil.isEmpty(eventsFromDeck.remove) then
        TableUtil.removeKey(eventsFromDeck, "remove")
    end

    if TableUtil.isEmpty(eventsFromDeck.bottomUp) then
        return nil
    end
    return eventsFromDeck
end

---@param card common__WrappedObject
---@return number
function Event.getNumber(card)
    local numberFromName = tonumber(card.getName())
    if numberFromName then
        return --[[---@not nil]] numberFromName
    end

    local cardId = card.getData().CardID
    local cardIndex = --[[---@not nil]] tonumber(tostring(cardId):sub(-2, -1))
    if cardIndex >= 22 then
        return cardIndex + 60
    end
    return cardIndex + 82
end

---@param info gh_EventDeckInfo
---@return common_DeckZone
function Event.getTargetDeck(info)
    ---@type tts__Vector
    local position
    if getObjectFromGUID(Component.guids.OLD_EVENT_MAT) then
        if info.oldMat then
            position = Utils.getSnapPosition(--[[---@not nil]] getObjectFromGUID(--[[---@not nil]] info.oldMat), 1)
        else
            position = Utils.getSnapPosition(--[[---@not nil]] getObjectFromGUID(Component.guids.EVENTS_MAT), 1)
        end
    else
        position = Utils.getSnapPosition(--[[---@not nil]] getObjectFromGUID(Component.guids.EVENTS_MAT), info.snapPoint)
    end

    return DeckUtil.wrapAt(position)
end

return Event
