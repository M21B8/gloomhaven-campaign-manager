events = {}

function events.load(values)
  events.read(values.city, guids.CITY_EVENTS_FIRST, guids.CITY_EVENTS, snaps.CITY_EVENTS)
  events.read(values.road, guids.ROAD_EVENTS_FIRST, guids.ROAD_EVENTS, snaps.ROAD_EVENTS)
end


function events.save()
  eventTypes = {}
  eventTypes.city = events.saveEventsFromDeck(snaps.CITY_EVENTS)
  eventTypes.road = events.saveEventsFromDeck(snaps.ROAD_EVENTS)

  return eventTypes
end


function events.read(values, firstDeckGuid, deckGuid, snapPoint)
  if not values then return end

  deck = getObjectFromGUID(deckGuid)
  deck.putObject(getObjectFromGUID(firstDeckGuid))

  local eventPosition = utils.getSnapPosition(getObjectFromGUID(guids.EVENTS_MAT), snapPoint)
  local eventsToTake = {}

  for i, event in pairs(values.bottomUp) do
    local eventName = string.format("%02d", event)
    local eventCard = utils.find_object_info_in_stack(deck, {name=eventName})
    deck.takeObject({
      guid = eventCard.guid,
      position = eventPosition + vector(0, i * 0.3, 0),
      rotation = rotations.NORTH,
      smooth = false
    })
  end
end


function events.saveEventsFromDeck(snapPosition)
  local eventPosition = utils.getSnapPosition(getObjectFromGUID(guids.EVENTS_MAT), snapPosition)
  local hitObjects = Physics.cast({
    origin = eventPosition + vector(0, -0.05, 0),
    direction = direction.UP,
    max_distance = 0.1
  })

  local eventsFromDeck = {}
  eventsFromDeck.bottomUp = {}
  for _, object in pairs(hitObjects) do
    object = object.hit_object
    if object.tag == "Deck" then
      local eventNumbers = {}
      for _, card in pairs(object.getObjects()) do
        table.insert(eventsFromDeck.bottomUp, tonumber(card.name))
      end
    end
  end

  return eventsFromDeck
end
