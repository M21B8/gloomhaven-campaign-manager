Event = {}

Event.DECKS = {
  ["city"] = {
    initialDeckGuid = guids.CITY_EVENTS_DECK_INITIAL,
    deckGuid = guids.CITY_EVENTS_DECK,
    snapPoint = snaps.CITY_EVENTS_DECK,
  },
  ["road"] = {
    initialDeckGuid = guids.ROAD_EVENTS_DECK_INITIAL,
    deckGuid = guids.ROAD_EVENTS_DECK,
    snapPoint = snaps.ROAD_EVENTS_DECK,
  },
}

function Event.loadAll(events)
  if not events then return end

  for _, eventDeck in pairs(events) do
    Event.load(eventDeck)
  end
end



function Event.load(events)
  local eventsInfo = Event.DECKS[events.deck]
  local deck = getObjectFromGUID(eventsInfo.deckGuid)
  deck.putObject(getObjectFromGUID(eventsInfo.initialDeckGuid))

  local bottomCards = Event.findBottomDeck(events, deck)
  local addedCards = Event.findAddedCards(events, deck, bottomCards)

  TableUtil.shuffle(addedCards)
  local eventCards = TableUtil.append(bottomCards, addedCards)

  Event.dealEvents(deck, eventCards, eventsInfo.snapPoint)
end


function Event.findBottomDeck(events, deck)
  if not events.bottomUp then return {} end

  local eventsToAdd = {}
  for i, event in pairs(events.bottomUp) do
    local eventName = string.format("%02d", event)
    local eventCard = Utils.findObjectInfoInStack(deck, {name=eventName})
    table.insert(eventsToAdd, eventCard.guid)
  end

  return eventsToAdd
end


function Event.findAddedCards(events, deck, alreadyAdded)
  local eventsToAdd = {}
  for _, eventCard in pairs(deck.getObjects()) do
    local eventNumber = tonumber(eventCard.name)
    if not TableUtil.contains(alreadyAdded, eventCard.guid)
       and Event.isAdded(events, eventNumber)
       and not Event.isRemoved(events, eventNumber)
    then
      table.insert(eventsToAdd, eventCard.guid)
    end
  end

  return eventsToAdd
end


function Event.isRemoved(events, eventNumber)
  return events.remove and TableUtil.contains(events.remove, eventNumber)
end


function Event.isAdded(events, eventNumber)
  return eventNumber <= 30
         or (events.add and TableUtil.contains(events.add, eventNumber))
end


function Event.dealEvents(deck, eventCards, snapPoint)
  local eventPosition = Event.getPosition(snapPoint)
  for i, event in pairs(eventCards) do
    local offset = i * 0.2
    deck.takeObject({
      guid = event,
      position = eventPosition + vector(0, offset, 0),
      rotation = Rotation.NORTH,
      smooth = false
    })
  end
end


function Event.save()
  events = {}

  for name, info in pairs(Event.DECKS) do
    local eventDeck = Event.saveEventsFromDeck(info.snapPoint)
    eventDeck.deck = name
    table.insert(events, eventDeck)
  end

  return events
end


function Event.saveEventsFromDeck(snapPoint)
  local hitObjects = Physics.cast({
    origin = Event.getPosition(snapPoint) + vector(0, -0.05, 0),
    direction = Direction.UP,
    max_distance = 0.1
  })

  local eventsFromDeck = {}
  eventsFromDeck.bottomUp = {}
  for _, object in pairs(hitObjects) do
    object = object.hit_object
    if object.tag == "Deck" then
      local eventNumbers = {}
      for _, card in pairs(object.getObjects()) do
        table.insert(eventsFromDeck.bottomUp, tonumber(card.name))
      end
    end
  end

  return eventsFromDeck
end


function Event.getPosition(snapPoint)
  return Utils.getSnapPosition(getObjectFromGUID(guids.EVENTS_MAT), snapPoint)
end
