Character = {}


function Character.load(index, character)
  local playerZone = guids.ZONES[index]
  getObjectFromGUID(guids.ADD_PLAYERS[index]).call("addPlayer")

  Utils.waitForObjectInZone(playerZone, {name=names.PLAYER_MAT},
                            function() Character.unpackCharacterBox(playerZone, character) end)
end


function Character.unpackCharacterBox(playerZone, character)
  local playerMat = Component.playerMat(playerZone)
  local characterBox = getObjectFromGUID(Game.CLASSES[character.class].boxGuid)

  characterBox.takeObject({
    position = playerMat.getPosition()
  })

  Utils.waitForObjectInZone(playerZone, {name=names.CHARACTER_SHEET},
                            function() Character.doLoad(playerZone, character) end)
end


function Character.doLoad(playerZone, character)
  -- still need more waiting to init the UI of the sheet :-(
  Wait.time(function() Character.loadCharacterSheet(playerZone, character) end, 1)
  Wait.time(function() Character.loadMaxHp(playerZone, character) end, 5)
  Character.loadAbilities(playerZone, character)
  Character.loadQuest(playerZone, character)
end


function Character.loadCharacterSheet(playerZone, character)
  local characterSheet = Component.characterSheet(playerZone)

  if character.name then
    characterSheet.UI.setAttribute("Name", "text", character.name)
  end
  if character.gold then
    characterSheet.call('addEx', {name='gold', amount=character.gold})
  end
  if character.xp then
    characterSheet.call('addEx', {name='xp', amount=character.xp})
  end
  if character.checkmarks then
    for i=1, character.checkmarks do
      characterSheet.call('clickedToggle', "notes"..tostring(i))
    end
  end
  if character.perks then
    Character.loadPerks(playerZone, character)
  end
  if character.items then
    Character.loadItems(playerZone, character)
  end
  if character.notes then
    characterSheet.UI.setAttribute("NotesFront", "text", table.concat(character.notes, "\n"))
  end
  if character.hiddenNotes then
    characterSheet.UI.setAttribute("Notes", "text", table.concat(character.hiddenNotes, "\n"))
  end
end


function Character.loadMaxHp(playerZone, character)
  local characterInfo = Game.CLASSES[character.class]
  local level = Character.getLevel(character.xp)
  local maxHealth = characterInfo.hp[level]

  Character.loadFigureHealth(playerZone, character.class, maxHealth)
  local tokenName = characterInfo.hp[1] .. " hp"
  local healthToken = Utils.findObjectInZone(playerZone, {name=tokenName})
  healthToken.setState(maxHealth)

  if characterInfo.extraFigure then
    maxHealth = characterInfo.extraFigure.hp[level]
    Character.loadFigureHealth(playerZone, characterInfo.extraFigure.name, maxHealth)
  end
end


function Character.loadFigureHealth(playerZone, name, health)
  local figure = Utils.findObjectInZone(playerZone, {name=name, tag=Tag.FIGURINE})

  figure.getVar('health')["max"] = health
  figure.getVar('health')["value"] = health
  figure.call('setHealth')
end

function Character.loadAbilities(playerZone, character)
  if not character.abilities then return end

  local abilityDeck = Component.abilityDeck(playerZone)
  local secondHandPos = {abilityDeck.getPosition().x,3,-59}
  for _, ability in pairs(character.abilities) do
    local abilityCard = Utils.findObjectInfoInStack(abilityDeck, {name=ability})
    abilityDeck.takeObject({
      position = secondHandPos,
      guid = abilityCard.guid
    })
  end
end


function Character.loadQuest(playerZone, character)
  if not character.quest then return end

  local callback = function(card) card.setPosition(positions.relativeToZone(playerZone, positions.QUEST_CARD)) end
  Quest.take(character.quest, callback)
end


function Character.loadPerks(playerZone, character)
  local perkInfo = Game.CLASSES[character.class].perks
  local characterSheet = Component.characterSheet(playerZone)
  local modifierDeck = Utils.findObjectInZone(playerZone, {name=names.MODIFIER_DECK, description="Player"})
  local isOtherDeck = function(obj) return obj.getName():find(names.MODIFIER_DECK)
                                           and obj.getGUID() ~= modifierDeck.getGUID()
                                    end
  local additionalModifierDeck = Utils.findObjectInZone(playerZone, {func=isOtherDeck})

  for _, perk in pairs(character.perks) do
    characterSheet.call('clickedToggle', "perk"..tostring(perk))
    Character.adjustAttackModifierDeck(modifierDeck, additionalModifierDeck, perkInfo[perk])
    if additionalModifierDeck.remainder then
      -- Remainder may only live for a single frame after last card is taken
      -- May need to move this into the adjustAttackModifierDeck routine itself to reduce
      -- any delay.
      additionalModifierDeck = additionalModifierDeck.remainder
    end
  end

  modifierDeck.shuffle()
end


function Character.adjustAttackModifierDeck(modifierDeck, additionalModifierDeck, info)
  if info.add then
    for _, card in pairs(info.add) do
      if additionalModifierDeck.tag == Tag.CARD then
        additionalModifierDeck.putObject(modifierDeck)
        break
      end
      local foundCard = Character.findModifierCard(additionalModifierDeck, card)
      additionalModifierDeck.takeObject({
        guid = foundCard.guid,
        position = positions.getSafe(),
        smooth = false,
        callback_function = function(card) card.putObject(modifierDeck) end
      })
    end
  end

  if info.remove then
    for _, card in pairs(info.remove) do
      local foundCard = Character.findModifierCard(modifierDeck, card)
      modifierDeck.takeObject({
        guid = foundCard.guid,
        position = positions.getSafe(),
        smooth = false,
        callback_function = function(card) card.destruct() end})
    end
  end

  if info.ignore then
  end
end


function Character.findModifierCard(deck, name)
  local searchPattern = "^" .. names.ATTACK_MODIFIER .. " " .. StringUtil.escapePattern(name) .. "$"
  return Utils.findObjectInfoInStack(deck, {name=searchPattern})
end


function Character.loadItems(playerZone, character)
  local characterSheet = Component.characterSheet(playerZone)
  local playerMat = Component.playerMat(playerZone)

  local itemsText = ""
  for _, item in pairs(character.items) do
    local itemPosition
    if item.position and snaps[item.position] then
      itemPosition = Utils.getSnapPosition(playerMat, snaps[item.position])
    else
      itemPosition = positions.relativeToZone(playerZone, positions.ITEM_UNEQUIPPED)
    end
    Shop.takeItem(item.name, itemPosition)
    itemsText = itemsText .. "\n" .. item.name
  end
  characterSheet.UI.setAttribute("Items", "text", itemsText)
end


function Character.moveToHand(object, playerZone, hand)
  local playerName = Game.PLAYERS[playerZone]
  object.deal(1, playerName, hand)
end


function Character.getLevel(curXP)
  for i, xp in pairs(Game.XP_REQUIREMENTS) do
    if curXP < xp then
      return i-1
    end
  end
  return 9
end


function Character.save(playerZone)
  local characterMat = Component.characterMat(playerZone)
  if not characterMat then
    return {}
  end

  local playerMat = Component.playerMat(playerZone)
  local characterSheet = Component.characterSheet(playerZone)
  local characterSheetButtons = characterSheet.getTable("buttons")

  character = {}
  character.class = characterMat.getDescription()
  character.name = characterSheet.UI.getAttribute("Name", "text")
  character.xp = tonumber(characterSheet.UI.getAttribute("xp", "text"))
  character.gold = tonumber(characterSheet.UI.getAttribute("gold", "text"))
  character.notes = StringUtil.split(characterSheet.UI.getAttribute("NotesFront", "text"), {"\n"})
  character.hiddenNotes = StringUtil.split(characterSheet.UI.getAttribute("Notes", "text"), {"\n"})

  local totalCheckmarks = 0
  for i=1, 18 do
    if characterSheetButtons["notes"..i].label ~= "" then
      totalCheckmarks = totalCheckmarks + 1
    end
  end
  character.checkmarks = totalCheckmarks

  character.perks = {}
  for i=1, 15 do
    if characterSheetButtons["perk"..i].label ~= "" then
      table.insert(character.perks, i)
    end
  end

  character.items = Character.saveItems(playerZone)
  character.abilities = Character.saveAbilities(playerZone)
  character.quest = Character.saveQuest(playerZone)

  return character
end


function Character.saveItems(playerZone)
  local playerMat = Utils.findObjectInZone(playerZone, {name=names.PLAYER_MAT})
  local items = {}
  for _, object in pairs(getObjectFromGUID(playerZone).getObjects()) do
    if Component.IsItemCard(object) then
      local item = {name=object.getName(), position=Character.getItemPosition(playerMat, object)}
      table.insert(items, item)
    elseif object.tag == Tag.DECK then
      for _, card in pairs(object.getObjects()) do
        if Component.IsItemCardInfo(card) then
          local item = {name=card.name, position=Character.getItemPosition(playerMat, object)}
          table.insert(items, item)
        end
      end
    end
  end

  return items
end


function Character.getItemPosition(playerMat, object)
  -- TODO The snap module is used for all snap points not only player mat snaps. So this currently
  -- only works, because the player mat snaps are defined first. This should be changed, so that it
  -- works regardless of definition order
  for name, snap in pairs(snaps) do
    if Utils.getSnapPosition(playerMat, snap) == object.getPosition() then
      return name
    end
  end

  return "Unequipped"
end


function Character.saveAbilities(playerZone)
  local class = Character.findClassInZone(playerZone)
  local abilities = {}

  for _, object in pairs(getObjectFromGUID(playerZone).getObjects()) do
    if Component.isAbilityCardForClass(object, class) then
      local name = Component.getAbilityName(object)
      if not Component.isStartingAbility(name, class) then
        table.insert(abilities, name)
      end
    end
  end

  return abilities
end


function Character.saveQuest(playerZone)
  for _, object in pairs(getObjectFromGUID(playerZone).getObjects()) do
    if Component.isPersonalQuestCard(object) then
      local cardId = object.getData().CardID
      local cardIndex = tonumber(tostring(cardId):sub(-2, -1))
      for name, quest in pairs(Game.QUESTS) do
        if quest.index == cardIndex then return name end
      end
    end
  end
  return nil
end


function Character.findZoneForClass(className)
  for _, playerZone in pairs(guids.ZONES) do
    local characterMat = Component.characterMat(playerZone)
    if characterMat and characterMat.getDescription() == className then
      return playerZone
    end
  end
  return nil
end


function Character.findClassInZone(playerZone)
  local characterMat = Component.characterMat(playerZone)
  if characterMat then
    return characterMat.getDescription()
  end
  return nil
end
