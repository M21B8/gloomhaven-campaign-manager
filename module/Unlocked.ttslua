local Constant = require("sebaestschjin-tts.src.Constant")
local EventManager = require('ge_tts.EventManager')
local Error = require("sebaestschjin-tts.src.Error")
local Logger = require('sebaestschjin-tts.module.Logger')
local ObjectUtil = require('sebaestschjin-tts.src.ObjectUtil')
local TableUtil = require("sebaestschjin-tts.src.TableUtil")
local Utils = require("sebaestschjin-tts.src.Utils")

local Component = require("gloomhaven-campaign-manager.module.Component")
local EventType = require("gloomhaven-campaign-manager.module.EventType")
local Game = require("gloomhaven-campaign-manager.module.Game")
local Preparation = require("gloomhaven-campaign-manager.module.Preparation")
local Sanctuary = require("gloomhaven-campaign-manager.module.Sanctuary")
local Shop = require("gloomhaven-campaign-manager.module.Shop")
local Task = require("gloomhaven-campaign-manager.module.Task")

local Unlocked = {}

function Unlocked.loadAll(unlocked)
    if unlocked then
        Task.load("Opening Conditions", unlocked.specialConditions, Unlocked.validateOpeningConditions, Unlocked.loadOpeningConditions)
        Task.start("Load Treasures", { input = unlocked.treasures,
                                       execute = Unlocked.loadTreasures,
                                       finish = EventType.TREASURE_LOADED })
        Sanctuary.load(unlocked.sanctuary)
    else
        EventManager.triggerEvent(EventType.TREASURE_LOADED)
    end
end

function Unlocked.validateClasses(classes)
    for i, class in pairs(classes) do
        local classInfo = Game.CLASSES[class]
        if not classInfo then
            Error.add("Class '%s' does not exist. Class won't be loaded.", class)
            classes[i] = nil
        elseif classInfo.isStartingClass then
            Error.add("Class '%s' is already a starting class and doesn't need unlocking.", class)
            classes[i] = nil
        end
    end

    return true, Error.pop()
end

---@param content gh_Savefile
---@param className string
function Unlocked.mayLoadClass(content, className)
    if not content.unlocked or not content.unlocked.classes then
        EventManager.triggerEvent(EventType.CLASS_UNLOCKED, className)
        return
    end

    local class = Game.class(className)
    if class and class.isStartingClass then
        EventManager.triggerEvent(EventType.CLASS_UNLOCKED, className)
        return
    end

    for i, unlockedClass in TableUtil.ipairs(content.unlocked.classes) do
        if unlockedClass == className then
            Unlocked.loadClass(i, className)
            return
        end
    end
    EventManager.triggerEvent(EventType.CLASS_UNLOCKED, className)
end

function Unlocked.loadClasses(classes)
    Utils.waitForObject(Component.guids.LOCKED_CLASSES, function() Unlocked.doLoadClasses(classes) end)
end

function Unlocked.doLoadClasses(classes)
    for i, class in pairs(classes) do
        Unlocked.loadClass(i, class)
    end
end

---@param number number
---@param className string
function Unlocked.loadClass(number, className)
    Logger.info('Unlocking class %s', className)

    local characterBoxes = getObjectFromGUID(Component.guids.LOCKED_CLASSES)
    local lastBox = getObjectFromGUID(Component.guids.LAST_BOX)
    local beforeLastBox = getObjectFromGUID(Component.guids.BEFORE_LAST_BOX)
    local delta = (lastBox.getPosition() - beforeLastBox.getPosition()) * number

    characterBoxes.takeObject({
        position = lastBox.getPosition() + delta,
        rotation = lastBox.getRotation(),
        smooth = false,
        guid = Game.CLASSES[className].boxGuid,
        callback_function = function(obj)
            obj.setLock(true)
            EventManager.triggerEvent(EventType.CLASS_UNLOCKED, className)
        end
    })
end

function Unlocked.validateItems(items)
    for i, item in pairs(items) do
        local foundItem = Shop.findItem(item)
        if not foundItem then
            Error.add("The item '%s' does not exist. Won't load item.", item)
            items[i] = nil
        end
    end
    return true, Error.pop()
end

---@param content gh_Savefile
function Unlocked.loadItems(content)
    if content.unlocked and content.unlocked.items then
        local cityMat = getObjectFromGUID(Component.guids.CITY_MAT)
        local shopPosition = Utils.getSnapPosition(cityMat, Component.snaps.SHOP)

        for _, item in pairs(content.unlocked.items) do
            Shop.takeRewardItem(item, shopPosition)
        end
    end
    EventManager.triggerEvent(EventType.ITEMS_UNLOCKED)
end

function Unlocked.validateOpeningConditions()
    return true, {}
end

function Unlocked.loadOpeningConditions(openingConditions)
    Preparation.takeFromGamebox(Component.guids.OPENING_CONDITIONS, Component.positions.OPENING_CONDITIONS)
    Utils.waitForObject(Component.guids.OPENING_CONDITIONS, function() Unlocked.doLoadOpeningConditions(openingConditions) end)
end

function Unlocked.doLoadOpeningConditions(openingConditions)
    Unlocked.setOpeningCondition(openingConditions.ancientTechnology, "Ancient")
    Unlocked.setOpeningCondition(openingConditions.drakeAided, "Drake")
    Unlocked.setOpeningCondition(openingConditions.lowReputation, "RepN10")
    Unlocked.setOpeningCondition(openingConditions.lowestReputation, "RepN20")
    Unlocked.setOpeningCondition(openingConditions.highReputation, "Rep10")
    Unlocked.setOpeningCondition(openingConditions.highestReputation, "Rep20")

    if openingConditions.retired then
        getObjectFromGUID(Component.guids.OPENING_CONDITIONS).call("clickedToggle", "Retire")
        getObjectFromGUID(Component.guids.GAMEBOX).takeObject({
            guid = Component.guids.TOWN_RECORDS,
            position = Component.positions.TOWN_RECORDS,
            rotation = Constant.Rotation.NORTH,
            smooth = false
        })
    end

    if openingConditions.donations then
        for i = 1, openingConditions.donations do
            Unlocked.setOpeningCondition(true, "Donation" .. i)
        end
        if openingConditions.donations >= 10 then
            Unlocked.setOpeningCondition(true, "DonationFull")
        end
    end
end

function Unlocked.setOpeningCondition(condition, name)
    if condition then
        getObjectFromGUID(Component.guids.OPENING_CONDITIONS).call("clickedToggle", name)
    end
end

function Unlocked.validateTreasures(treasures)
    for i, treasure in ipairs(treasures) do
        if treasure < 0 or treasure > Unlocked.TOTAL_TREASURE then
            treasures[i] = nil
            Error.add("Treasure '%s' does not exist. Treasure won't be loaded.", treasure)
        end
    end

    return true, Error.pop()
end

function Unlocked.loadTreasures(treasures)
    local treasureDeck = getObjectFromGUID(Component.guids.TREASURE_DECK)

    for _, treasure in ipairs(treasures) do
        local treasureCard = Utils.findObjectIn(treasureDeck, { name = tostring(treasure) })
        if not treasureCard then
            Logger.error("Treasure '%s' does not exist. Treasure won't be loaded.", treasure)
        else
            treasureDeck.takeObject({
                index = treasureCard.index,
                position = Component.positions.getSafe(),
                callback_function = function(obj) obj.destruct() end,
            })
        end
    end

    EventManager.triggerEvent(EventType.TREASURE_LOADED)
end

function Unlocked.saveAll(saveFile)
    saveFile.unlocked = {
        classes = Unlocked.saveClasses(),
        sanctuary = Sanctuary.save(),
        specialConditions = Unlocked.saveOpeningConditions(),
        treasures = Unlocked.saveTreasures(),
    }
    Shop.save(saveFile.unlocked)
end

function Unlocked.saveClasses()
    local classes = {}
    for class, info in pairs(Game.CLASSES) do
        local box = getObjectFromGUID(info.boxGuid)
        if box and not info.isStartingClass then
            table.insert(classes, class)
        end
    end

    return TableUtil.emptyToNil(classes)
end

function Unlocked.saveOpeningConditions()
    local openingConditionsSheet = getObjectFromGUID(Component.guids.OPENING_CONDITIONS)
    if not openingConditionsSheet then
        return nil
    end

    local openingConditions = {}
    local buttons = openingConditionsSheet.getTable("buttons")
    openingConditions.ancientTechnology = buttons["Ancient"].label ~= ""
    openingConditions.drakeAided = buttons["Drake"].label ~= ""
    openingConditions.lowReputation = buttons["RepN10"].label ~= ""
    openingConditions.lowestReputation = buttons["RepN20"].label ~= ""
    openingConditions.highReputation = buttons["Rep10"].label ~= ""
    openingConditions.highestReputation = buttons["Rep20"].label ~= ""
    openingConditions.retired = buttons["Retire"].label ~= ""
    local donations = 0
    for i = 1, 10 do
        if buttons["Donation" .. i].label ~= "" then
            donations = donations + 1
        end
    end
    openingConditions.donations = donations

    return openingConditions
end

function Unlocked.saveTreasures()
    local treasureDeck = getObjectFromGUID(Component.guids.TREASURE_DECK)
    if not treasureDeck then
        treasureDeck = Utils.findObjectIn(getObjectFromGUID(Component.guids.GAMEBOX), { guid = Component.guids.TREASURE_DECK })
    end

    if not treasureDeck then
        Logger.warn('Could not find the treasure deck in the gamebox or on the board. Can not save unlocked treasures.')
        return {}
    end

    local treasure = {}
    for i = 1, Unlocked.TOTAL_TREASURE do
        treasure[i] = true
    end

    local treasureCards = ObjectUtil.getContainedObjects(treasureDeck)
    for _, treasureCard in pairs(treasureCards) do
        local treasureNumber = tonumber(treasureCard.getName():sub(-2))
        treasure[treasureNumber] = false
    end

    return TableUtil.setToList(treasure)
end

return Unlocked
